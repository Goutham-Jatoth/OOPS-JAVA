ğŸ“ Project Structure
src/
 â””â”€â”€ com/
      â””â”€â”€ payments/
           â”œâ”€â”€ contracts/
           â”‚     â””â”€â”€ PaymentGateway.java
           â”œâ”€â”€ core/
           â”‚     â””â”€â”€ AbstractPaymentProcessor.java
           â”œâ”€â”€ impl/
           â”‚     â”œâ”€â”€ CreditCardProcessor.java
           â”‚     â””â”€â”€ NetBankingProcessor.java
           â””â”€â”€ app/
                 â””â”€â”€ Main.java

ğŸ§© Code Files
1ï¸âƒ£ PaymentGateway.java

ğŸ“¦ com.payments.contracts

package com.payments.contracts;

public interface PaymentGateway {

    // Abstract method
    void validateCredentials();

    // Default method (Java 8)
    default void timeoutCheck() {
        logDetail("Checking for network timeout...");
    }

    // Static method (Java 8)
    static boolean isGatewayAvailable() {
        System.out.println("Performing gateway availability check...");
        return true;
    }

    // Private method (Java 9)
    private void logDetail(String msg) {
        System.out.println("Interface Log: " + msg);
    }
}

2ï¸âƒ£ AbstractPaymentProcessor.java

ğŸ“¦ com.payments.core

package com.payments.core;

import com.payments.contracts.PaymentGateway;

public abstract class AbstractPaymentProcessor implements PaymentGateway {

    // Template method (final to prevent override)
    public final void processTransaction(double amount) {
        System.out.println("\n--- Starting Transaction ---");
        System.out.println("Transaction Amount: â‚¹" + amount);

        // Step 1: Validate credentials (abstract method)
        validateCredentials();

        // Step 2: Timeout check (from interface)
        timeoutCheck();

        // Step 3: Confirm transaction
        confirmTransaction();

        System.out.println("--- Transaction Completed ---\n");
    }

    // Common step for all payment processors
    protected void confirmTransaction() {
        System.out.println("Confirming transaction...");
    }
}

3ï¸âƒ£ CreditCardProcessor.java

ğŸ“¦ com.payments.impl

package com.payments.impl;

import com.payments.core.AbstractPaymentProcessor;

public class CreditCardProcessor extends AbstractPaymentProcessor {

    @Override
    public void validateCredentials() {
        System.out.println("Validating credit card details (CVV, Expiry Date, etc.)...");
    }

    // Overriding the default method
    @Override
    public void timeoutCheck() {
        System.out.println("Performing secure credit card timeout check...");
    }
}

4ï¸âƒ£ NetBankingProcessor.java

ğŸ“¦ com.payments.impl

package com.payments.impl;

import com.payments.core.AbstractPaymentProcessor;

public class NetBankingProcessor extends AbstractPaymentProcessor {

    @Override
    public void validateCredentials() {
        System.out.println("Verifying NetBanking credentials (User ID, Password, OTP)...");
    }

    // Uses the default timeoutCheck() from interface
}

5ï¸âƒ£ Main.java

ğŸ“¦ com.payments.app

package com.payments.app;

import com.payments.contracts.PaymentGateway;
import com.payments.core.AbstractPaymentProcessor;
import com.payments.impl.CreditCardProcessor;
import com.payments.impl.NetBankingProcessor;

public class Main {
    public static void main(String[] args) {

        // Step 1: Check if gateway is available
        if (PaymentGateway.isGatewayAvailable()) {
            System.out.println("âœ… Payment Gateway is available.\n");
        }

        // Step 2: Use polymorphism to handle different processors
        AbstractPaymentProcessor creditCard = new CreditCardProcessor();
        AbstractPaymentProcessor netBanking = new NetBankingProcessor();

        // Step 3: Process transactions
        creditCard.processTransaction(2500.75);
        netBanking.processTransaction(5200.00);
    }
}

ğŸ§  Output Example
Performing gateway availability check...
âœ… Payment Gateway is available.


--- Starting Transaction ---
Transaction Amount: â‚¹2500.75
Validating credit card details (CVV, Expiry Date, etc.)...
Performing secure credit card timeout check...
Confirming transaction...
--- Transaction Completed ---


--- Starting Transaction ---
Transaction Amount: â‚¹5200.0
Verifying NetBanking credentials (User ID, Password, OTP)...
Interface Log: Checking for network timeout...
Confirming transaction...
--- Transaction Completed ---

âœ… Concepts Demonstrated
Concept	Where Itâ€™s Used
Abstract Class	AbstractPaymentProcessor
Interface with Static, Default, Private methods	PaymentGateway
Method Overriding	timeoutCheck() in CreditCardProcessor
Polymorphism	AbstractPaymentProcessor references in Main.java
Template Method Pattern	processTransaction() in AbstractPaymentProcessor
Package Structure	Clean modular organization (contracts, core, impl, app)












JAVA MINI PROJECT RECORD
Title:

Simple Java Project on Abstract Classes & Interfaces â€“ Payment Processing System

Objective:

To design and implement a Java program that demonstrates:

The use of Abstract Classes for defining core structure and shared logic.

The use of Interfaces for defining a strict contract of operations.

Interface Enhancements like default, static, and private methods.

The concept of Method Overriding and Polymorphism to handle multiple payment types uniformly.

The use of Packages to create a professional, modular structure.

Theory:

In Java, abstraction allows developers to hide complex logic and expose only essential operations.
This can be achieved using abstract classes and interfaces.

ğŸ”¹ Abstract Class

An abstract class can have both abstract (unimplemented) and concrete (implemented) methods.
It defines a base structure that subclasses extend and provide specific implementations.
In this project, it acts as a template for the payment process.

ğŸ”¹ Interface

An interface defines a strict contract that all implementing classes must follow.
Since Java 8 and 9, interfaces can also contain:

Default Methods â€“ methods with default implementations.

Static Methods â€“ utility methods called via the interface name.

Private Methods â€“ helper methods used within the interface only.

ğŸ”¹ Template Method Pattern

The abstract class defines a final method that represents the complete workflow (e.g., processTransaction()), while subclasses customize only certain parts.

ğŸ”¹ Polymorphism

By referring to objects through their abstract superclass, the same method can exhibit different behaviors depending on the object type (e.g., CreditCard vs. NetBanking).

Program:
ğŸ“¦ com.payments.contracts.PaymentGateway.java
package com.payments.contracts;

public interface PaymentGateway {

    void validateCredentials();

    default void timeoutCheck() {
        logDetail("Checking for network timeout...");
    }

    static boolean isGatewayAvailable() {
        System.out.println("Performing gateway availability check...");
        return true;
    }

    private void logDetail(String msg) {
        System.out.println("Interface Log: " + msg);
    }
}

ğŸ“¦ com.payments.core.AbstractPaymentProcessor.java
package com.payments.core;

import com.payments.contracts.PaymentGateway;

public abstract class AbstractPaymentProcessor implements PaymentGateway {

    public final void processTransaction(double amount) {
        System.out.println("\n--- Starting Transaction ---");
        System.out.println("Transaction Amount: â‚¹" + amount);

        validateCredentials();
        timeoutCheck();
        confirmTransaction();

        System.out.println("--- Transaction Completed ---\n");
    }

    protected void confirmTransaction() {
        System.out.println("Confirming transaction...");
    }
}

ğŸ“¦ com.payments.impl.CreditCardProcessor.java
package com.payments.impl;

import com.payments.core.AbstractPaymentProcessor;

public class CreditCardProcessor extends AbstractPaymentProcessor {

    @Override
    public void validateCredentials() {
        System.out.println("Validating credit card details (CVV, Expiry Date, etc.)...");
    }

    @Override
    public void timeoutCheck() {
        System.out.println("Performing secure credit card timeout check...");
    }
}

ğŸ“¦ com.payments.impl.NetBankingProcessor.java
package com.payments.impl;

import com.payments.core.AbstractPaymentProcessor;

public class NetBankingProcessor extends AbstractPaymentProcessor {

    @Override
    public void validateCredentials() {
        System.out.println("Verifying NetBanking credentials (User ID, Password, OTP)...");
    }
}

ğŸ“¦ com.payments.app.Main.java
package com.payments.app;

import com.payments.contracts.PaymentGateway;
import com.payments.core.AbstractPaymentProcessor;
import com.payments.impl.CreditCardProcessor;
import com.payments.impl.NetBankingProcessor;

public class Main {
    public static void main(String[] args) {

        if (PaymentGateway.isGatewayAvailable()) {
            System.out.println("âœ… Payment Gateway is available.\n");
        }

        AbstractPaymentProcessor creditCard = new CreditCardProcessor();
        AbstractPaymentProcessor netBanking = new NetBankingProcessor();

        creditCard.processTransaction(2500.75);
        netBanking.processTransaction(5200.00);
    }
}

Sample Output:
Performing gateway availability check...
âœ… Payment Gateway is available.


--- Starting Transaction ---
Transaction Amount: â‚¹2500.75
Validating credit card details (CVV, Expiry Date, etc.)...
Performing secure credit card timeout check...
Confirming transaction...
--- Transaction Completed ---


--- Starting Transaction ---
Transaction Amount: â‚¹5200.0
Verifying NetBanking credentials (User ID, Password, OTP)...
Interface Log: Checking for network timeout...
Confirming transaction...
--- Transaction Completed ---

Result:

The Java program was successfully executed and demonstrated:

Use of Abstract Class and Interface concepts.

Implementation of static, default, and private methods in an interface.

Method Overriding and Polymorphism for flexible behavior.

Proper use of package structure and template method pattern.

âœ… Hence, the project successfully simulates a Payment Processing System using Abstract Classes & Interfaces.
